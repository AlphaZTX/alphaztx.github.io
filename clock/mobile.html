<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>What time is it? (Touch Version)</title>
  <style>
    @font-face {
      font-family: 'AlphaClockVF';
      src: url('assets/fonts/ttf/AlphaClockVF.ttf') format('truetype');
      font-display: swap;
    }

    body {
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      background: #0f0f0f;
      color: #eeeeee;
      font-family: 'AlphaClockVF', system-ui, sans-serif;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      touch-action: none;
    }

    a {
      color: #eeeeee;
      text-decoration: none;
    }

    #controls {
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      background: #222;
      font-family: system-ui, sans-serif;
      z-index: 10;
      position: relative;
    }

    #leftControls {
      display: flex;
      align-items: center;
      gap: 20px;
      overflow-x: auto;
      white-space: nowrap;
      -webkit-overflow-scrolling: touch;
    }

    #rightControls {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    #featureToggles {
      display: flex;
      flex-direction: row;
      flex-wrap: nowrap;
      gap: 12px;
    }

    .feature-block {
      flex: 0 0 auto;
    }

    .feature-block label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 16px;
      color: #ccc;
      cursor: pointer;
    }

    #datetime {
      flex-grow: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      contain: strict;
    }

    #datetimeText {
      font-variation-settings: 'wght' 500, 'ytuc' 100;
      font-feature-settings: normal;
      will-change: transform, font-variation-settings;
      backface-visibility: hidden;
      transform: translateZ(0);
    }

    button {
      padding: 8px 14px;
      border-radius: 8px;
      font-size: 16px;
      background-color: #444;
      color: white;
      opacity: 0.7;
      border: none;
      cursor: pointer;
      transition: opacity 0.2s;
      -webkit-tap-highlight-color: transparent;
    }

    button:hover {
      opacity: 1;
    }

    #lockStatus {
      padding: 8px 14px;
      border-radius: 8px;
      font-size: 16px;
      background-color: #444;
      color: white;
      opacity: 0.7;
      transition: opacity 0.2s;
    }

    #metrics {
      display: flex;
      flex-direction: column;
      padding: 10px 16px;
      font-family: system-ui, sans-serif;
      background: #111;
      gap: 10px;
      position: absolute;
      right: 0;
      bottom: 0;
      align-items: flex-end;
      text-align: right;
      z-index: 10;
      contain: content;
    }

    .metric {
      display: flex;
      align-items: center;
      font-size: 14px;
      gap: 10px;
      will-change: transform;
    }

    .metric-label {
      width: 6em;
      text-align: right;
      flex-shrink: 0;
    }

    .copyrightText {
      font-size: 14px;
      opacity: 0.5;
    }

    .bar {
      height: 8px;
      max-width: 6em;
      width: 6em;
      background: #444;
      border-radius: 4px;
      overflow: hidden;
      flex-grow: 1;
      contain: strict;
    }

    .fill {
      height: 100%;
      background: #2af;
      will-change: width;
      transition: width 0.1s ease-out;
    }

    #fpsDisplay {
      font-size: 14px;
      opacity: 0.5;
    }

    input[type="range"] {
      height: 10px;
      background: #444;
      border-radius: 5px;
      cursor: pointer;
      width: 100px;
    }

    input[type="range"]::-webkit-slider-thumb {
      /* -webkit-appearance: none; */
      width: 20px;
      height: 20px;
      background: #2af;
      border-radius: 50%;
    }

    /* 新增触摸控制手柄样式 */
    #touchControl {
      position: absolute;
      width: 60px;
      height: 60px;
      background-color: rgba(42, 170, 255, 0.5);
      border-radius: 50%;
      z-index: 5;
      cursor: move;
      touch-action: none;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 24px;
      user-select: none;
      -webkit-user-select: none;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }

    #touchControl::after {
      content: "☝️";
    }

    #touchArea {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 4;
      display: none;
    }

    /* 触摸设备特定样式 */
    @media (hover: none) {
      #touchControl, #touchArea {
        display: flex;
      }
      
      #controls {
        padding: 15px;
      }
      
      button, #lockStatus {
        padding: 10px 16px;
        font-size: 18px;
      }
      
      input[type="range"] {
        height: 12px;
        width: 120px;
      }
      
      input[type="range"]::-webkit-slider-thumb {
        width: 24px;
        height: 24px;
      }
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/opentype.js@latest/dist/opentype.min.js"></script>
</head>
<body>
  <div id="controls">
    <div id="leftControls">
      <b><a href="https://alphaztx.github.io" target="_blank">Home</a></b>
      <span></span>
      <label for="fontSize">Font Size</label>
      <input type="range" id="fontSize" min="40" max="128" value="80" />
      <span></span>
      <label for="featureToggles">Features</label>
      <div id="featureToggles"></div>
    </div>
    <div id="rightControls">
      <button id="soundToggle">Sound Control: OFF</button>
      <div id="lockStatus">Touch and drag the handle to control</div>
    </div>
  </div>
  <div id="datetime"><div id="datetimeText">Loading...</div></div>
  <div id="touchControl"></div>
  <div id="touchArea"></div>
  <div id="metrics">
    <div class="metric">
      <div class="metric-label">Weight</div>
      <div class="bar"><div id="wghtBar" class="fill" style="width:0%"></div></div>
    </div>
    <div class="metric">
      <div class="metric-label">Height</div>
      <div class="bar"><div id="ytucBar" class="fill" style="width:0%"></div></div>
    </div>
    <div id="fpsDisplay">FPS: --</div>
    <div class="copyrightText">© Copyright 2025 AlphaZTX</div>
  </div>

  <script>
    const datetimeText = document.getElementById('datetimeText');
    const fontSizeSlider = document.getElementById('fontSize');
    const soundToggle = document.getElementById('soundToggle');
    const featureTogglesContainer = document.getElementById('featureToggles');
    const lockStatus = document.getElementById('lockStatus');
    const wghtBar = document.getElementById('wghtBar');
    const ytucBar = document.getElementById('ytucBar');
    const fpsDisplay = document.getElementById('fpsDisplay');
    const touchControl = document.getElementById('touchControl');
    const touchArea = document.getElementById('touchArea');
    const featureToggles = {};

    let wghtRange = [100, 1000];
    let ytucRange = [100, 250];
    let currentWght = 500;
    let currentYtuc = 100;
    let mouseControlEnabled = true;
    let soundControlEnabled = false;
    let audioContext, analyser, microphone, dataArray;
    let availableFeatures = [];
    const tagLookupMap = new Map();
  
    let lastWght = null;
    let lastYtuc = null;

    let lastFrame = performance.now();
    let frameCount = 0;
    let fps = 0;
    let animationFrameId = null;
    let lastMouseUpdate = 0;

    let volume = 0;
    let volumeFactor = 2;
    let reducedVolume = 0;
    let pitchRatio = 0;
    let pitchRatioFactor = 2;
    let reducedPitchRatio = 0;

    let targetWght = 500;
    let targetYtuc = 100;
    let transitionDuration = 800; // 过渡时间(毫秒)
    let transitionStartTime = 0;
    let isTransitioning = false;

    // 触摸控制相关变量
    let isDragging = false;
    let startX, startY;
    let touchControlX = window.innerWidth / 2;
    let touchControlY = window.innerHeight / 2;

    // 初始化触摸控制手柄位置
    function initTouchControl() {
      touchControlX = window.innerWidth / 2;
      touchControlY = window.innerHeight / 2;
      updateTouchControlPosition();
    }

    // 更新触摸控制手柄位置
    function updateTouchControlPosition() {
      touchControl.style.left = `${touchControlX - 30}px`;
      touchControl.style.top = `${touchControlY - 30}px`;
      updateAxesFromTouchControl();
    }

    // 根据触摸控制手柄位置更新轴值
    function updateAxesFromTouchControl() {
      const x = touchControlX / window.innerWidth;
      const y = 1 - (touchControlY / window.innerHeight);
      
      targetWght = wghtRange[0] + (wghtRange[1] - wghtRange[0]) * x;
      targetYtuc = ytucRange[0] + (ytucRange[1] - ytucRange[0]) * y;
      
      if (!isTransitioning) {
        isTransitioning = true;
        transitionStartTime = performance.now();
      }
    }

    // 设置触摸事件监听
    function setupTouchControls() {
      touchControl.addEventListener('touchstart', handleTouchStart, { passive: false });
      touchControl.addEventListener('touchmove', handleTouchMove, { passive: false });
      touchControl.addEventListener('touchend', handleTouchEnd, { passive: false });
      
      // 备用触摸区域，防止手柄滑出屏幕
      touchArea.addEventListener('touchstart', handleTouchStart, { passive: false });
      touchArea.addEventListener('touchmove', handleTouchMove, { passive: false });
      touchArea.addEventListener('touchend', handleTouchEnd, { passive: false });
      
      // 鼠标事件（用于支持混合设备）
      touchControl.addEventListener('mousedown', handleMouseDown);
    }

    function handleTouchStart(e) {
      e.preventDefault();
      isDragging = true;
      const touch = e.touches[0];
      startX = touch.clientX - touchControlX;
      startY = touch.clientY - touchControlY;
      touchControl.style.opacity = '1';
    }

    function handleTouchMove(e) {
      if (!isDragging) return;
      e.preventDefault();
      const touch = e.touches[0];
      touchControlX = Math.max(0, Math.min(window.innerWidth, touch.clientX - startX));
      touchControlY = Math.max(0, Math.min(window.innerHeight, touch.clientY - startY));
      updateTouchControlPosition();
    }

    function handleTouchEnd(e) {
      isDragging = false;
      touchControl.style.opacity = '0.7';
    }

    function handleMouseDown(e) {
      e.preventDefault();
      isDragging = true;
      startX = e.clientX - touchControlX;
      startY = e.clientY - touchControlY;
      touchControl.style.opacity = '1';
      
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
    }

    function handleMouseMove(e) {
      if (!isDragging) return;
      e.preventDefault();
      touchControlX = Math.max(0, Math.min(window.innerWidth, e.clientX - startX));
      touchControlY = Math.max(0, Math.min(window.innerHeight, e.clientY - startY));
      updateTouchControlPosition();
    }

    function handleMouseUp(e) {
      isDragging = false;
      touchControl.style.opacity = '0.7';
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    }

    // 使用防抖函数优化事件处理
    function debounce(func, wait) {
      let timeout;
      return function() {
        const context = this;
        const args = arguments;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
      };
    }

    // 使用节流函数优化高频事件
    function throttle(func, limit) {
      let lastFunc;
      let lastRan;
      return function() {
        const context = this;
        const args = arguments;
        if (!lastRan) {
          func.apply(context, args);
          lastRan = Date.now();
        } else {
          clearTimeout(lastFunc);
          lastFunc = setTimeout(function() {
            if ((Date.now() - lastRan) >= limit) {
              func.apply(context, args);
              lastRan = Date.now();
            }
          }, limit - (Date.now() - lastRan));
        }
      };
    }

    function updateMetrics(timestamp) {
      const now = performance.now();
      frameCount++;
      
      if (now - lastFrame >= 1000) {
        fps = Math.round(frameCount * 1000 / (now - lastFrame));
        frameCount = 0;
        lastFrame = now;
        fpsDisplay.textContent = `FPS: ${fps}`;
      }
      
      // 平滑过渡逻辑
      if (isTransitioning) {
        const elapsed = timestamp - transitionStartTime;
        const progress = Math.min(elapsed / transitionDuration, 1);
        
        currentWght = easeInOutQuad(progress, currentWght, targetWght - currentWght, 1);
        currentYtuc = easeInOutQuad(progress, currentYtuc, targetYtuc - currentYtuc, 1);
        
        if (progress >= 1) {
          isTransitioning = false;
        }
      }
      
      const roundedWght = parseFloat(currentWght.toFixed(1));
      const roundedYtuc = parseFloat(currentYtuc.toFixed(1));
      
      if (roundedWght !== lastWght || roundedYtuc !== lastYtuc) {
        lastWght = roundedWght;
        lastYtuc = roundedYtuc;
        
        datetimeText.style.fontVariationSettings =
          `'wght' ${roundedWght}, 'ytuc' ${roundedYtuc}`;

        const wPct = ((roundedWght - wghtRange[0]) / (wghtRange[1] - wghtRange[0])) * 100;
        const yPct = ((roundedYtuc - ytucRange[0]) / (ytucRange[1] - ytucRange[0])) * 100;
        wghtBar.style.width = `${wPct}%`;
        ytucBar.style.width = `${yPct}%`;
      }
      
      animationFrameId = requestAnimationFrame(updateMetrics);
    }

    function easeInOutQuad(t, b, c, d) {
      t /= d/2;
      if (t < 1) return c/2*t*t + b;
      t--;
      return -c/2 * (t*(t-2) - 1) + b;
    }

    function startAnimationLoop() {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      updateMetrics();
    }

    async function loadFontAxesAndFeatures() {
      try {
        const font = new FontFace('AlphaClockVF', 'url(assets/fonts/ttf/AlphaClockVF.ttf)');
        await font.load();
        document.fonts.add(font);
    
        if (font.variationAxes) {
          for (const axis of font.variationAxes) {
            if (axis.tag === 'wght') wghtRange = [axis.minValue, axis.maxValue];
            if (axis.tag === 'ytuc') ytucRange = [axis.minValue, axis.maxValue];
          }
        }
    
        const response = await fetch('assets/fonts/ttf/AlphaClockVF.ttf');
        const arrayBuffer = await response.arrayBuffer();
        const fontObj = opentype.parse(arrayBuffer);
    
        const gsub = fontObj.tables.gsub;
        if (gsub && gsub.features && gsub.lookups) {
          const featureTags = new Set();
          for (const featureRecord of gsub.features) {
            const tag = featureRecord.tag;
            const lookupIndexes = featureRecord.feature.lookupListIndexes;
            featureTags.add(tag);
            if (!tagLookupMap.has(tag)) tagLookupMap.set(tag, []);
            for (const lookupIndex of lookupIndexes) {
              const lookup = gsub.lookups[lookupIndex];
              if (lookup) {
                tagLookupMap.get(tag).push({
                  index: lookupIndex,
                  type: lookup.lookupType,
                  subTables: lookup.subtables || []
                });
              }
            }
          }
          availableFeatures = Array.from(featureTags).sort();
          createFeatureToggles();
          if (featureToggles['tnum']) featureToggles['tnum'].checked = true;
          updateFontFeatures();
        }
      } catch (error) {
        console.error('Error loading font:', error);
      }
    }
  
    function createFeatureToggles() {
      featureTogglesContainer.innerHTML = '';
      for (const feature of availableFeatures) {
        const id = `${feature}Toggle`;
        const wrapper = document.createElement('div');
        wrapper.className = 'feature-block';
  
        const label = document.createElement('label');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = id;
        checkbox.dataset.feature = feature;
        checkbox.addEventListener('change', debounce(updateFontFeatures, 50));
  
        label.appendChild(checkbox);
        label.append(` ${feature}`);
        wrapper.appendChild(label);
        featureTogglesContainer.appendChild(wrapper);
        featureToggles[feature] = checkbox;
      }
    }
  
    function updateFontFeatures() {
      const features = [];
      for (const tag in featureToggles) {
        features.push(`'${tag}' ${featureToggles[tag].checked ? 'on' : 'off'}`);
      }
      datetimeText.style.fontFeatureSettings = features.join(', ');
    }
  
    function updateDateTime() {
      const now = new Date();
      const yyyy = now.getFullYear();
      const mm = String(now.getMonth() + 1).padStart(2, '0');
      const dd = String(now.getDate()).padStart(2, '0');
      const hh = String(now.getHours()).padStart(2, '0');
      const mm2 = String(now.getMinutes()).padStart(2, '0');
      const ss = String(now.getSeconds()).padStart(2, '0');
      datetimeText.textContent = `${yyyy}-${mm}-${dd} ${hh}:${mm2}:${ss}`;
      
      // 只在秒变化时更新，减少不必要的DOM操作
      setTimeout(updateDateTime, 1000 - now.getMilliseconds());
    }
  
    function toggleMouseControl() {
      mouseControlEnabled = !mouseControlEnabled;
      lockStatus.textContent = mouseControlEnabled ? 'Touch Control: ON' : 'Touch Control: OFF';
      lockStatus.style.opacity = '1';
      setTimeout(() => lockStatus.style.opacity = '0.7', 1000);
      
      if (mouseControlEnabled) {
        // 启用控制时开始平滑过渡
        isTransitioning = true;
        transitionStartTime = performance.now();
        // 初始值与当前值相同，实际目标值由控制手柄位置决定
        targetWght = currentWght;
        targetYtuc = currentYtuc;
      }
    }
  
    async function toggleSoundControl() {
      if (soundControlEnabled) {
        soundControlEnabled = false;
        mouseControlEnabled = true;
        soundToggle.textContent = 'Sound Control: OFF';
        soundToggle.style.opacity = '0.7';
        if (microphone) microphone.disconnect();
        if (analyser) analyser.disconnect();
        if (audioContext) await audioContext.close();
        return;
      }
      
      try {
        soundControlEnabled = true;
        mouseControlEnabled = false;
        soundToggle.textContent = 'Sound Control: ON';
        soundToggle.style.opacity = '1';
    
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        microphone = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 64; // 减少FFT大小以提高性能
        dataArray = new Uint8Array(analyser.frequencyBinCount);
    
        microphone.connect(analyser);
    
        function analyze() {
          if (!soundControlEnabled) return;
          
          analyser.getByteFrequencyData(dataArray);
          
          // 优化计算：只分析中间频率范围
          const start = Math.floor(dataArray.length * 0.3);
          const end = Math.floor(dataArray.length * 0.7);
          let sum = 0;
          let maxAmp = 0, maxIdx = start;
          
          for (let i = start; i < end; i++) {
            sum += dataArray[i];
            if (dataArray[i] > maxAmp) {
              maxAmp = dataArray[i];
              maxIdx = i;
            }
          }
          
          volume = sum / (end - start);
          reducedVolume = Math.min(1, volume * volumeFactor / 255);
          currentWght = wghtRange[0] + (wghtRange[1] - wghtRange[0]) * reducedVolume;
          
          pitchRatio = (maxIdx - start) / (end - start);
          reducedPitchRatio = Math.min(1, pitchRatio * pitchRatioFactor);
          currentYtuc = ytucRange[0] + (ytucRange[1] - ytucRange[0]) * reducedPitchRatio;
          
          requestAnimationFrame(analyze);
        }
    
        analyze();
      } catch (error) {
        console.error('Error accessing microphone:', error);
        soundControlEnabled = false;
        mouseControlEnabled = true;
        soundToggle.textContent = 'Sound Control: OFF';
        soundToggle.style.opacity = '0.7';
      }
    }

    // 事件监听器
    soundToggle.addEventListener('click', toggleSoundControl);
    fontSizeSlider.addEventListener('input', debounce(() => {
      datetimeText.style.fontSize = `${fontSizeSlider.value}px`;
    }, 50));

    // 初始化
    loadFontAxesAndFeatures();
    updateDateTime();
    datetimeText.style.fontSize = `${fontSizeSlider.value}px`;
    initTouchControl();
    setupTouchControls();
    startAnimationLoop();
    
    // 清理
    window.addEventListener('beforeunload', () => {
      if (animationFrameId) cancelAnimationFrame(animationFrameId);
      if (soundControlEnabled && audioContext) audioContext.close();
    });

    // 窗口大小改变时重新定位控制手柄
    window.addEventListener('resize', () => {
      touchControlX = Math.min(touchControlX, window.innerWidth);
      touchControlY = Math.min(touchControlY, window.innerHeight);
      updateTouchControlPosition();
    });
  </script>
</body>
</html>